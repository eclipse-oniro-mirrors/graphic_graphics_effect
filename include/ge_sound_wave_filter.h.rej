diff a/include/ge_sound_wave_filter.h b/include/ge_sound_wave_filter.h	(rejected hunks)
@@ -40,13 +40,13 @@ public:
  
 private:
     void CheckSoundWaveParams();
+    void CheckSoundWaveColor4f(Drawing::Color4f& color);
     std::shared_ptr<Drawing::RuntimeEffect> GetSoundWaveEffect();
     // sound wave
-    Drawing::Color colorA_ = Drawing::Color::COLOR_WHITE;
-    Drawing::Color colorB_ = Drawing::Color::COLOR_WHITE;
-    Drawing::Color colorC_ = Drawing::Color::COLOR_WHITE;
+    Drawing::Color4f colorA_ = {1.0, 1.0, 1.0, 1.0};
+    Drawing::Color4f colorB_ = {1.0, 1.0, 1.0, 1.0};
+    Drawing::Color4f colorC_ = {1.0, 1.0, 1.0, 1.0};
     float colorProgress_ = 0.0f;
-    float centerBrightness_ = 1.0f;
     float soundIntensity_ = 0.0f;
 
     // shock wave
@@ -84,32 +87,31 @@ private:
             vec3 returnValue = mix(colorA, colorB, smoothstep(startPos, endPos, threshold)) * stepValue;
             return returnValue;
         }
- 
-        vec3 colorWheel(vec2 uv, vec2 circleCenter, float circleRadius, float animationTime)
+
+        vec3 colorWheel(vec2 uv, float animationTime)
         {
-            float mask = length(uv+circleCenter) / circleRadius;
-            float distanceFromCenter = fract(mask-animationTime);
- 
-            vec3 color = colorGradient(colorA, colorB, 0.0, 0.2, distanceFromCenter)
-                         + colorGradient(colorB, colorC, 0.2, 0.6, distanceFromCenter)
-                         + colorGradient(colorC, colorA, 0.6, 1.0, distanceFromCenter);
+            float mask = length(uv) / (circleRadius + 2.0);
+            float distanceFromCenter = fract(mask - animationTime);
+
+            vec3 color = colorGradient(colorA, colorB, 0.0, 0.2, distanceFromCenter) +
+                        colorGradient(colorB, colorC, 0.2, 0.6, distanceFromCenter) +
+                        colorGradient(colorC, colorA, 0.6, 1.0, distanceFromCenter);
             color *= (1.0 - step(1.0, mask));
             return color;
         }
- 
+
         vec4 soundWaveDistortionEffects(vec2 screenUVs, vec2 centeredUVs, float animationTime)
         {
-            vec2 lightPulseUVs = centeredUVs + vec2(0.0, 1.12); // uv minus pulse center position
-            float frequency = fract(animationTime); // frequency of distortion waves
-            float radius = mix(0.17, 0.68, frequency);
+            vec2 lightPulseUVs = centeredUVs + vec2(0.0, 0.1);        // uv minus pulse center position
+            float frequency = fract(animationTime);  // frequency of distortion waves
+            float radius = mix(0.14, 0.52, frequency);
             float lightPulseDistance = length(lightPulseUVs) - radius;
- 
+
             float lightPulseThickness = 0.12;
             float lightPulse = smoothstep(lightPulseThickness, -0.025, abs(lightPulseDistance));
-            if (lightPulse > 0.0)
-            {
+            if (lightPulse > 0.0) {
                 float animationMask = smoothstep(1.0, 0.4, frequency);
- 
+
                 vec2 directionVector = normalize(lightPulseUVs);
                 vec2 normal = directionVector * lightPulseDistance * lightPulse * animationMask;
                 vec2 refractedUVs = clamp(mix(screenUVs, screenUVs - normal * 0.25, 0.3), 0.001, 0.999);
@@ -117,67 +119,73 @@ private:
             }
             return vec4(screenUVs, 0.0, 0.0);
         }
- 
-        vec3 soundWaveLightEffects(vec2 uv, vec2 centeredUVs, vec3 currentColor, vec3 centerColor)
+
+        vec3 soundWaveLightEffects(vec2 centeredUVs, vec3 currentColor, vec3 centerColor)
         {
-            float circleRadius = 0.125;
- 
             // Control the height of the circle
-            float circleHeight = mix(-0.2, 0.03, soundIntensity);
-            float spreadX = pow(100.0, -soundIntensity) + 1.0;// Control the spread of the mask across X
- 
+            float circleHeight = mix(-0.4, 0.03, soundIntensity);
+
             float smoothUnionThreshold = mix(0.0657, 0.09, soundIntensity);
-            float horizonOffset = -0.02;
             vec2 circlePosition = vec2(0.0, circleHeight);
-            centeredUVs.y += 1.0;
-            centeredUVs.y += mix(0.09, 0.0, soundIntensity);
-            float circleSDF = length(centeredUVs-circlePosition)-circleRadius ;
+
+            float barPosition = mix(0.09, 0.0, soundIntensity);
+            float circleSDF = length(centeredUVs - circlePosition) - circleRadius;
+            centeredUVs.y += barPosition;
+
             circleSDF += smoothUnionThreshold;
-            float smoothUnionDistance = smin(circleSDF, centeredUVs.y-horizonOffset, smoothUnionThreshold);
-            float horizontalGradient = smoothstep(0.9 * spreadX, 0.0, abs(uv.x*2.0-1.0));
+            float smoothUnionDistance = smin(circleSDF, centeredUVs.y, smoothUnionThreshold);
+
+            float horizontalGradient = smoothstep(0.75, 0.0, abs(centeredUVs.x));
             float smoothGap = mix(0.08, 0.1085, horizontalGradient);
             float smoothUnion = smoothstep(smoothGap, -0.035, mix(0.0, 0.66, smoothUnionDistance));
- 
-            // Control the spread of the mask across X
-            smoothUnion *= mix(0.65, 1.0, horizontalGradient);
- 
-            float brightnessValue = centerBrightness *smoothstep(5.0, 0.0, circleSDF);
- 
-            return currentColor+centerColor*smoothUnion* brightnessValue;
+
+            float verticalGradient = centeredUVs.y - barPosition;
+            verticalGradient =
+                1.0 - min(smoothUnionThreshold - barPosition, verticalGradient) / (smoothUnionThreshold - barPosition);
+            float gradient = mix(1.0, horizontalGradient, 1.0 - verticalGradient) * horizontalGradient;
+            smoothUnion *= gradient;
+
+            return currentColor + centerColor * smoothUnion;
         }
- 
-        half4 main(float2 fragCoord) {
-            vec2 uv = fragCoord.xy/iResolution.xy;
+
+        half4 main(float2 fragCoord)
+        {
+            vec2 uv = fragCoord.xy / iResolution.xy;
             uv.y = 1.0 - uv.y;
-            if (uv.y>0.3) {
-                return vec4(0.0);
-            }
-            float screenRatio = iResolution.x/iResolution.y;
-            vec2 centeredUVs = uv*2.0 - 1.0;
+
+            vec2 adjustedResolution = vec2(iResolution.x, iResolution.y * 4.);
+            float screenRatio = adjustedResolution.x / adjustedResolution.y;
+            vec2 centeredUVs = uv * 2.0 - 1.0 + vec2(0.0, 1.0);
+            centeredUVs *= iResolution.xy / adjustedResolution;
             centeredUVs.x *= screenRatio;
-            vec2 screenUVs = uv;
- 
-            vec3 finalColor = vec3(0.);
-            vec3 centerColor = colorWheel(centeredUVs, vec2(0.0, 1.0), 2.125, colorProgress);
- 
+
+            vec3 finalColor = vec3(0.0);
+            vec3 centerColor = colorWheel(centeredUVs, colorProgress);
+
             // Shock wave distort
             vec4 soundWaveDistortionA = vec4(0.0);
             vec4 soundWaveDistortionB = vec4(0.0);
-            soundWaveDistortionA = soundWaveDistortionEffects(uv, centeredUVs, shockWaveProgressA);
-            soundWaveDistortionB = soundWaveDistortionEffects(soundWaveDistortionA.xy, centeredUVs, shockWaveProgressB);
-            uv = soundWaveDistortionB.xy;
- 
-            finalColor.rgb = image.eval(vec2(uv.x, 1.0 - uv.y) * iResolution.xy).rgb;
+            if (shockWaveTotalAlpha > 0.0) {
+                soundWaveDistortionA = soundWaveDistortionEffects(uv, centeredUVs, shockWaveProgressA);
+                soundWaveDistortionB =
+                    soundWaveDistortionEffects(soundWaveDistortionA.xy, centeredUVs, shockWaveProgressB);
+                uv = soundWaveDistortionB.xy;
+            }
+
+            finalColor = image.eval(vec2(uv.x, 1.0 - uv.y) * iResolution.xy).rgb;
             // Sound wave Effect
-            finalColor.rgb = soundWaveLightEffects(screenUVs, centeredUVs, finalColor.rgb, centerColor);
- 
-            // Shock wave Effect: Add sutil light from the refraction distortion
-            finalColor.rgb = finalColor.rgb + centerColor * soundWaveDistortionA.z * shockWaveAlphaA;
-            finalColor.rgb = finalColor.rgb + centerColor * pow(soundWaveDistortionA.w, 6.0) * 0.3 * shockWaveAlphaA;
- 
-            finalColor.rgb = finalColor.rgb + centerColor * soundWaveDistortionB.z * shockWaveAlphaB;
-            finalColor.rgb = finalColor.rgb + centerColor * pow(soundWaveDistortionB.w, 6.0) * 0.3 * shockWaveAlphaB;
- 
+            finalColor = soundWaveLightEffects(centeredUVs, finalColor, centerColor);
+
+            if (shockWaveTotalAlpha > 0.0) {
+                // Shock wave Effect: Add sutil light from the refraction distortion
+                float AlphaA = shockWaveAlphaA * shockWaveTotalAlpha;
+                float AlphaB = shockWaveAlphaB * shockWaveTotalAlpha;
+                finalColor += centerColor * soundWaveDistortionA.z * AlphaA;
+                finalColor += centerColor * pow(soundWaveDistortionA.w, 6.0) * 0.3 * AlphaA;
+                finalColor += centerColor * soundWaveDistortionB.z * AlphaB;
+                finalColor += centerColor * pow(soundWaveDistortionB.w, 6.0) * 0.3 * AlphaB;
+            }
+
             return vec4(finalColor, 1.0);
         }
     )";
